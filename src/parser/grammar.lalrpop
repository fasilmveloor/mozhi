use crate::lexer::tokens::*;
use crate::lexer::LexicalError;
use crate::executor::ast::*;

grammar(input: &str);

pub SourceUnit:SourceUnit = {
    SourceUnitPart+ => SourceUnit(<>)
};

SourceUnitPart:SourceUnitPart = {
    Statement => SourceUnitPart::Statement(<>),
};

Expressions = Comma<Expression>;
Comma<T>:Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}
Statement:Statement = {
    <a:@L> <l:Expression> "=" <r:Expression> ";" <b:@R> => Statement::Assignment((a,b),l,r),
    <a:@L> <l:Expression> Input Do ";" <b:@R> => Statement::Input((a,b),l),
    <a:@L> <e:Expression> Ennu Write ";" <b:@R> => Statement::Write((a,b),e),
    <a:@L> <e:Expression> Write ";" <b:@R> => Statement::Write((a,b),e),
    <a:@L> <e:Expression> Ennu Print Do ";" <b:@R> => Statement::Write((a,b),e),
    <a:@L> <condition:Conditional> "{" <s:SourceUnit> "}" <b:@R> => Statement::Conditional((a,b),condition,s,None),
    <a:@L> <condition:Conditional> "{" <s:SourceUnit> "}" Else "{" <f:SourceUnit> "}" <b:@R> => Statement::Conditional((a,b),condition,s,Some(f)),
    <a:@L> <name:Expression> "(" <params:Expressions> ")" "{" <s:SourceUnit> "}" <b:@R> => Statement::FunctionDeclaration((a,b),name,params,s),
    <a:@L> Return <expr:Expression> ";" <b:@R>  => Statement::Return((a,b),expr),
    <a:@L> <expr:Expression> ";" <b:@R>  => Statement::EmptyExpression((a,b),expr),
    <a:@L> Loop <condition:Conditional> "{" <s:SourceUnit> "}" <b:@R> => Statement::Loop((a,b),condition,s),
    <a:@L> <term:Term> Thavana Loop "{" <s:SourceUnit> "}" <b:@R> => Statement::ForLoop((a,b),term,s)
}; 

Expression:Expression= {
    ArithExpression
}

Conditional:Expression = {
    <l:Expression> "ഉം"  <r:Expression> "ഉം" <a:@L> "==" <b:@R> => Expression::Equals((a,b),Box::new(l),Box::new(r)),
    <l:Expression>  "ഉം" <r:Expression> "ഉം" <a:@L> "!=" <b:@R>  => Expression::NotEquals((a,b),Box::new(l),Box::new(r)),
    <r:Expression>  "നെകാൾ" <l:Expression> <a:@L> ">" <b:@R> => Expression::GreaterThan((a,b),Box::new(l),Box::new(r)),
    <r:Expression>  "നെകാൾ" <l:Expression> <a:@L> "<" <b:@R> => Expression::LessThan((a,b),Box::new(l),Box::new(r)),
    <r:Expression>  "നെകാൾ" <l:Expression> <a:@L> ">=" <b:@R> => Expression::GreaterThanOrEqual((a,b),Box::new(l),Box::new(r)),
    <r:Expression>  "നെകാൾ" <l:Expression> <a:@L> "<=" <b:@R> => Expression::LessThanOrEqual((a,b),Box::new(l),Box::new(r)),
    Term,
};

ArithExpression: Expression = {
    <l:ArithExpression> <a:@L> "+" <b:@R> <r:Factor> => Expression::Add((a,b),Box::new(l),Box::new(r)),
    <l:ArithExpression> <a:@L> "-" <b:@R> <r:Factor> => Expression::Subtract((a,b),Box::new(l),Box::new(r)),
    Factor,
};

Factor: Expression= {
    <l:Factor> <a:@L> "*" <b:@R> <r:Unary> => Expression::Multiply((a,b),Box::new(l),Box::new(r)),
    <l:Factor> <a:@L> "/" <b:@R> <r:Unary> => Expression::Divide((a,b),Box::new(l),Box::new(r)),
    <l:Factor> <a:@L> "%" <b:@R> <r:Unary> => Expression::Modulo((a,b),Box::new(l),Box::new(r)),
    Unary,
};

Unary:Expression = {
    <a:@L> "-" <b:@R> <r:Unary> => Expression::UnaryMinus((a,b),Box::new(r)),
    Term
};

Term: Expression= {
    <a:@L> <v:Integer> <b:@R> => Expression::Integer((a,b),v),
    <a:@L> <v:Float> <b:@R> => Expression::Float((a,b),v),
    <a:@L> <id:Identifier> <b:@R> => Expression::Symbol((a,b),id),
    <a:@L> <string:StringLiteral> <b:@R> => Expression::StringLiteral((a,b),string),
    <a:@L> <id:Term> "തുറക്കുക" <args:Expressions> "അടക്കുക"  <b:@R>  => Expression::FunctionCall((a,b),Box::new(id),args),
    "(" <e:Expression> ")" => e
};

extern {
    type Location = usize;
    type Error = LexicalError;

    enum TokenType {
        Identifier => TokenType::Symbol(usize),
        ";" => TokenType::SemiColon,
        "=" => TokenType::Assignment,
        Integer => TokenType::Integer(i64),
        Float => TokenType::Float(f64),
        StringLiteral => TokenType::Literal(usize),
        "+" => TokenType::Plus,
        "-" => TokenType::Minus,
        "*" => TokenType::Product,
        "/" => TokenType::Divide,
        "(" => TokenType::OpenParantheses,
        ")" => TokenType::CloseParantheses,
        Write => TokenType::Write,
        If => TokenType::If,
        Else => TokenType::Else,
        ">" => TokenType::GreaterThan,
        "<" => TokenType::LessThan,
        ">=" => TokenType::GreaterThanOrEqual,
        "<=" => TokenType::LessThanOrEqual,
        "==" => TokenType::EqualTo,
        "!=" => TokenType::NotEqual,
        "{" => TokenType::LeftBrace,
        "}" => TokenType::RightBrace,
        "%" => TokenType::Modulo,
        "ഉം" => TokenType::Um,
        "നെകാൾ" => TokenType::Nekal,
        "," => TokenType::Comma,
        Loop => TokenType::Loop,
        "തുറക്കുക" => TokenType::AngleOpen,
        "അടക്കുക" => TokenType::AngleClose,
        Input => TokenType::Input,
        Return => TokenType::Return,
        Do => TokenType::Do,
        Ennu => TokenType::Ennu,
        Thavana => TokenType::Thavana,
        Print => TokenType::Print,
    }
}